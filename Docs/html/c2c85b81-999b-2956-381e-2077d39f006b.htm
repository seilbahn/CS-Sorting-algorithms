<!DOCTYPE html ><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="shortcut icon" href="../icons/favicon.ico" /><link rel="stylesheet" href="../css/bulma.css" /><link rel="stylesheet" href="../css/font-awesome.min.css" /><link rel="stylesheet" href="../css/presentationStyle.css" /><link rel="stylesheet" href="../css/vs.min.css" /><script src="../scripts/jquery-3.5.1.min.js"></script><script src="../scripts/clipboard.min.js"></script><script src="../scripts/highlight.min.js"></script><script src="../scripts/presentationStyle.js"></script><title>SortingAlgorithm Enumeration</title><meta name="Title" content="SortingAlgorithm" /><meta name="Help.Id" content="T:Sorting.SortingAlgorithm" /><meta name="Help.ContentType" content="Reference" /><meta name="container" content="Sorting" /><meta name="guid" content="c2c85b81-999b-2956-381e-2077d39f006b" /><meta name="Description" content="The enumeration SortingAlgorithm contains names of sorting algorithms." /><meta name="tocFile" content="../toc/IDA.xml" /></head><body><div class="fixedLayout"><div id="Header" class="fixedHeader"><div class="pageHeader level mb-0 py-2 px-4"><div id="TitleContainer" class="level-left"><div id="DocumentationTitle" class="level-item">A Sandcastle Documented Class Library</div></div><div id="LangFilterSearchContainer" class="level-right"><div class="level-item"><div class="dropdown is-hoverable"><div class="dropdown-trigger"><button class="button" aria-haspopup="true" aria-controls="dropdown-menu"><span id="CurrentLanguage"></span><span class="icon is-small"><i class="fa fa-angle-down" aria-hidden="true"></i></span></button></div><div class="dropdown-menu" role="menu"><div id="LanguageSelections" class="dropdown-content"><a class="dropdown-item languageFilterItem" data-languageId="cs">C#</a></div></div></div></div><div class="level-item"><form id="SearchForm" action="#" onsubmit="TransferToSearchPage(); return false;"><div class="field"><div class="control has-icons-left"><input id="SearchTerms" class="input" type="text" maxlength="200" placeholder="Search" /><span class="icon is-small is-left"><i class="fa fa-search"></i></span><button id="SearchButton" type="submit" class="is-hidden"></button></div></div></form></div></div></div></div><div class="fixedContent"><nav class="breadcrumb my-1 px-2 border-bottom" role="navigation"><ul id="TopicBreadcrumbs" /></nav><div class="columns pl-5 pr-5 fixedContent"><div id="ShowHideTOCColumn" class="column is-hidden-tablet"><a id="ShowHideTOC">Show/Hide TOC</a></div><div id="TOCColumn" class="column is-hidden-mobile"><nav class="toc"><ul id="TableOfContents" class="toc-menu" /></nav></div><div id="TopicContent" class="column content is-7"><h1>Sorting<wbr />Algorithm Enumeration</h1><div class="summary">
            The enumeration SortingAlgorithm contains names of sorting algorithms.
            </div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Definition</h2><div id="IDBSection"><strong>Namespace:</strong> <a href="e0a1629f-63a8-3d0e-0483-0c14e8cf822b.htm">Sorting</a><br /><strong>Assembly:</strong> Sorting (in Sorting.dll) Version: 1.0.0<div class="codeSnippet"><div class="codeHeader"><span class="codeHeaderTitle">C#</span><span class="buttons"><button class="button is-small is-light copyCode" title="Copy"><span class="icon is-small"><i class="fa fa-copy"></i></span><span>Copy</span></button></span></div><div class="codePanel hljs"><pre xml:space="preserve"><code class="language-cs">[<span class="identifier">FlagsAttribute</span>]
<span class="keyword">public</span> <span class="keyword">enum</span> <span class="identifier">SortingAlgorithm</span></code></pre></div></div></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>Members</h2><div id="IDAEASection"><table id="enumMemberList" class="table is-hoverable"><tr><td>DefaultSort</td><td>0</td><td>
            The default value for the sorting algorithm name.
            </td></tr><tr><td>BubbleSort</td><td>1</td><td>
            The bubble sort, sometimes referred to as sinking sort,
            is a simple sorting algorithm that repeatedly steps through the input list element by element,
            comparing the current element with the one after it, swapping their values if needed.<br />
            These passes through the list are repeated until no swap had to be performed during a pass,
            meaning that the list has become fully sorted.<br />
            The algorithm, which is a comparison sort, is named for the way the larger elements "bubble" up to the top of the list.<br />
            This simple algorithm performs poorly in real world use and is used primarily as an educational tool. 
            </td></tr><tr><td>CocktailSort</td><td>2</td><td>
            The cocktail shaker sort, also known as bidirectional bubble sort,
            cocktail sort, shaker sort (which can also refer to a variant of selection sort),
            ripple sort, shuffle sort, or shuttle sort, is an extension of bubble sort.<br />
            The algorithm extends bubble sort by operating in two directions.<br />
            While it improves on bubble sort by more quickly moving items to the beginning of the list,
            it provides only marginal performance improvements.<br />
            Like most variants of bubble sort, cocktail shaker sort is used primarily as an educational tool. 
            </td></tr><tr><td>InsertionSort</td><td>4</td><td>
            The insertion sort iterates, consuming one input element each repetition, and grows a sorted output list.<br />
            At each iteration, insertion sort removes one element from the input data,
            finds the location it belongs within the sorted list, and inserts it there.<br />
            It repeats until no input elements remain.<br />
            Sorting is typically done in-place, by iterating up the array, growing the sorted list behind it.<br />
            At each array-position, it checks the value there against the largest value in the sorted list
            (which happens to be next to it, in the previous array-position checked).<br />
            If larger, it leaves the element in place and moves to the next.<br />
            If smaller, it finds the correct position within the sorted list, shifts all the larger values up to make a space,
            and inserts into that correct position. 
            </td></tr><tr><td>GnomeSort</td><td>8</td><td>
            The gnome sort is a variation of the insertion sort sorting algorithm that does not use nested loops.<br />
            It was first called stupid sort (not to be confused with bogosort), and then later named gnome sort.<br />
            The gnome sort performs at least as many comparisons as insertion sort and has the same asymptotic run time characteristics.<br />
            The sort works by building a sorted list one element at a time, getting each item to the proper place in a series of swaps.
            </td></tr><tr><td>MergeSort</td><td>16</td><td>
            The merge sort is an efficient, general-purpose, and comparison-based sorting algorithm.<br />
            Most implementations produce a stable sort, which means that the order of equal elements is the same in the input and output.
            Conceptually, a merge sort works as follows:<br />
            1.Dividing the unsorted list into n sublists, each containing one element (a list of one element is considered sorted).<br />
            2.Repeatedly merging sublists to produce new sorted sublists until there is only one sublist remaining.<br />
            This is the sorted list.
            </td></tr><tr><td>TreeSort</td><td>32</td><td>
            Tree sort is a sorting technique that is totally dependent on the data structure of a binary search tree.<br />
            In this sorting technique first, the binary search tree is created from the given data.<br />
            A binary search tree is a special type of binary tree in which,
            for each parent node, the left child will be lesser or smaller than the parent node
            and the right child will be equal or greater than the parent node.<br />
            In the case of a binary search tree, the inorder traversal always displays the elements in sorted order.
            Hence, this property is used in this sorting.<br />
            After creating the binary search tree, only the inorder traversal is performed to display the array in sorted order.
            </td></tr><tr><td>SelectionSort</td><td>64</td><td>
            The selection sort is an in-place comparison sorting algorithm.<br />
            It has an O(n^2) time complexity, which makes it inefficient on large lists,
            and generally performs worse than the similar insertion sort.
            It is noted for its simplicity and has performance advantages over more complicated algorithms in certain situations,
            particularly where auxiliary memory is limited.<br />
            The algorithm divides the input list into two parts:
            a sorted sublist of items which is built up from left to right at the front (left) of the list
            and a sublist of the remaining unsorted items that occupy the rest of the list.<br />
            Initially, the sorted sublist is empty and the unsorted sublist is the entire input list.<br />
            The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist,
            exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order),
            and moving the sublist boundaries one element to the right.
            </td></tr><tr><td>CombSort</td><td>128</td><td>
            The comb sort is mainly an improvement over the bubble sort.<br />
            The bubble sort always compares adjacent values.
            So all inversions are removed one by one.<br />
            The comb sort improves on the bubble sort by using a gap of the size of more than 1.<br />
            The gap starts with a large value and shrinks by a factor of 1.3 in every iteration until it reaches the value 1.<br />
            Thus the comb sort removes more than one inversion count with one swap and performs better than Bubble Sort.
            The shrink factor has been empirically found to be 1.3.<br />
            Although it works better than Bubble Sort on average, worst-case remains O(n^2).
            </td></tr><tr><td>ShellSort</td><td>256</td><td>
            The shellsort, also known as Shell sort or Shell's method, is an in-place comparison sort.<br />
            It can be seen as either a generalization of sorting by exchange (bubble sort) or sorting by insertion (insertion sort).<br />
            The method starts by sorting pairs of elements far apart from each other,
            then progressively reducing the gap between elements to be compared.<br />
            By starting with far apart elements, it can move some out-of-place elements into position faster than a simple nearest neighbor exchange.<br />
            The running time of Shellsort is heavily dependent on the gap sequence it uses.
            For many practical variants, determining their time complexity remains an open problem. 
            </td></tr><tr><td>HeapSort</td><td>512</td><td>
            The heapsort can be thought of as an improved selection sort:
            like selection sort, heapsort divides its input into a sorted and an unsorted region,
            and it iteratively shrinks the unsorted region by extracting the largest element from it
            and inserting it into the sorted region.<br />
            Unlike selection sort,heapsort does not waste time with a linear-time scan of the unsorted region;
            rather, heap sort maintains the unsorted region in a heap data structure to more quickly find the largest element in each step.<br />
            Although somewhat slower in practice on most machines than a well-implemented quicksort,
            it has the advantage of a more favorable worst-case O(n log n) runtime.<br />
            Heapsort is an in-place algorithm, but it is not a stable sort.
            </td></tr><tr><td>QuickSort</td><td>1,024</td><td>
            The quicksort is an efficient, general-purpose sorting algorithm.<br />
            It was developed by British computer scientist Tony Hoare in 1959 and published in 1961.
            It is still a commonly used algorithm for sorting.<br />
            Overall, it is slightly faster than merge sort and heapsort for randomized data, particularly on larger distributions.<br />
            This is a divide-and-conquer algorithm.
            It works by selecting a 'pivot' element from the array
            and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.<br />
            For this reason, it is sometimes called partition-exchange sort.<br />
            The sub-arrays are then sorted recursively. This can be done in-place, requiring small additional amounts of memory to perform the sorting.
            Most implementations of quicksort are not stable, meaning that the relative order of equal sort items is not preserved.<br />
            This implementation is also not stabil.
            </td></tr><tr><td>StoogeSort</td><td>2,048</td><td>
            The stooge sort is a recursive sorting algorithm.<br />
            It is notable for its exceptionally bad time complexity of O(nlog 3 / log 1.5 ) = O(n2.7095...).<br />
            The running time of the algorithm is thus slower compared to reasonable sorting algorithms,
            and is slower than bubble sort, a canonical example of a fairly inefficient sort.
            It is however more efficient than the slow sort.<br />
            The algorithm is defined as follows:<br />
            If the value at the start is larger than the value at the end, swap them.<br />
            If there are 3 or more elements in the list, then:<br />
            1.Stooge sort the initial 2/3 of the list;<br />
            2.Stooge sort the final 2/3 of the list;<br />
            3.Stooge sort the initial 2/3 of the list again.<br />
            It is important to get the integer sort size used in the recursive calls by rounding the 2/3 upwards,
            e.g. rounding 2/3 of 5 should give 4 rather than 3, as otherwise the sort can fail on certain data. 
            </td></tr><tr><td>BogoSort</td><td>4,096</td><td>
            The sorting algorithm is based on the generate and test paradigm.<br />
            The function successively generates permutations of its input until it finds one that is sorted.<br />
            It is not considered one of efficient algorithms for sorting.<br />
            It is recommended to sort with this algorithm no more than 10 elements,
            because of the very bad time complexity (in case of using a standart low-mid desktop-CPU).<br />
            The amount of comparizons is zero, because the algorithm does not compare keys,
            though there is a method for checking if the array is sorted.
            </td></tr></table></div><h2 class="quickLinkHeader"><span class="icon toggleSection" tabindex="0"><i class="fa fa-angle-down"></i></span>See Also</h2><div id="seeAlsoSection"><h4>Reference</h4><div><a href="e0a1629f-63a8-3d0e-0483-0c14e8cf822b.htm">Sorting Namespace</a></div></div></div><div id="InThisArticleColumn" class="column is-hidden-mobile"><nav class="menu sticky is-hidden"><p class="menu-label"><strong>In This Article</strong></p><ul id="InThisArticleMenu" class="menu-list"><li><a class="quickLink">Definition</a></li><li><a class="quickLink">Members</a></li><li><a class="quickLink">See Also</a></li></ul></nav></div></div></div><footer id="PageFooter" class="footer border-top py-3 fixedFooter"><div class="columns"><div class="column"> 
				</div><div class="column"> 
				</div></div></footer></div><script>$(function(){
SetDefaultLanguage("cs");
LoadTocFile(null, null);
InitializeQuickLinks();

$(".toggleSection" ).click(function () {
    SectionExpandCollapse(this);
});

$(".toggleSection").keypress(function () {
    SectionExpandCollapseCheckKey(this, event)
});
hljs.highlightAll();
});</script></body></html>